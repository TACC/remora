#!/bin/sh
#
#========================================================================
# HEADER
#========================================================================
#% DESCRIPTION
#% process_file: this is a temporary file for EuroMPI. We will further
#%               improve this file and move it to another location
#%
#% DO NOT call this script directly. This is called by REMORA
#%
#========================================================================
#- IMPLEMENTATION
#-      version     REMORA 1.8.1
#-      authors     Carlos Rosales (carlos@tacc.utexas.edu)
#-                  Antonio Gomez  (agomez@tacc.utexas.edu)
#-      license     MIT
#========================================================================

# Need to change this
input="/work/02658/agomez/tools/remora/testfiles/collectives.pst"
basepath="/work/02658/agomez/tools/remora/extra/mpi_collectives"

while IFS= read -r line
do
    #Skip lines starting with '#' (prob. not needed, but helpful)
    if [[ $line == \#* ]]; then
        continue
    fi
    arr=($line)
    #Using individual variables so that it is easier to understand
    #convert the function call to lowercase
    call=`echo ${arr[0]} | tr '[:upper:]' '[:lower:]'`
    nodes=${arr[1]}
    tasks=${arr[2]}
    msgsize=${arr[3]}

    time=${arr[4]}
    file="$basepath/$call/$nodes"
    file+="N"
    file+="$tasks"
    file+="n"
    foundfile=""
    if [ -f $file ]; then
        foundfile=$file
    else
        file="$basepath/$call/$nodes"
        file+="N"
        n=1
        found=0
        while [ $n -le $tasks ] ; do
            filenew="$file"
            filenew+="$n"
            filenew+="n"
            if [ -f $filenew ]; then
                found=1
                file=$filenew
            fi
            n=$[$n+1]
        done
        #Check if there is a file with the same number of nodes
        if [ $found -eq 1 ]; then
            #Find the closest number of tasks
            foundfile=$file
        else
            #there's no file with the same number of nodes
            #iterate over the files and get the one with the closest
            #number of nodes (floor)
            idx=1
            while [ $idx -le $nodes ] ; do
                file="$basepath/$call/$idx"
                file+="N"
                n=1
                while [ $n -le $tasks ]; do
                    filenew="$file"
                    filenew+="$n"
                    filenew+="n"
                    if [ -f $filenew ]; then
                        foundfile=$filenew
                    fi
                    n=$[$n+1]
                done
                idx=$[$idx+1]
            done
        fi 
    fi
    echo "Found match $foundfile"

    #Read the baseline file and get the best fit
    found_sz=1
    next_sz=4194304
    found_alg="default"
    while IFS= read -r baseline
    do
        if [[ $baseline == \#* ]]; then
            continue
        fi
        arr=($baseline)
        base_sz=`echo ${arr[0]}`
        base_alg=`echo ${arr[1]}`
        #While the message size in the file is smaller than the current
        #message size, update the value of the return value
        if [ $base_sz -le $msgsize ]; then
            found_sz=$base_sz
            found_alg=$base_alg
        else
            #Read the next value (if any). This is used for showing a range
            next_sz=$base_sz
            break
        fi
    done < "$foundfile" # $foundfile is the base file that we found before

    echo "Current size: " $msgsize
    echo "Best similar size: " $found_sz
    echo "Best algorithm: " $found_alg
#    if [ "$found_alg" == "default" ]; then
#        continue
#    fi

    mpi_func=`echo $call | tr '[:lower:]' '[:upper:]'`
    echo "Set I_MPI_ADJUST_$mpi_func=\"$found_alg:$found_sz-$next_sz\""
done < "$input"
